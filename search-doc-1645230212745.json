[{"title":"Configs","type":0,"sectionRef":"#","url":"docs/Common/configs","content":"","keywords":""},{"title":"Overview​","type":1,"pageTitle":"Configs","url":"docs/Common/configs#overview","content":"Springs are configurable and can be tuned. If you want to adjust these settings, you can provide a default config table to useSpring: local styles, api = RoactSpring.useSpring(hooks, function() return { from = { position = UDim2.fromScale(0.5, 0.5), rotation = 0, }, config = { mass = 10, tension = 100, friction = 50 }, } }) Copy Configs can also be adjusted when animating the spring. If there isn't any config provided, the default config will be used. api.start({ position = UDim2.fromScale(0.5, 0.5), rotation = 0, config = { mass = 10, tension = 100, friction = 50 }, }) Copy The following configs are available: Property\tDefault\tDescriptionmass\t1\tspring mass tension\t170\tspring energetic load friction\t26\tspring resistence clamp\tfalse\twhen true, stops the spring once it overshoots its boundaries velocity\t0\tinitial velocity, see velocity config for more detais easing\tt =&gt; t\tlinear by default, there is a multitude of easings available here damping\t1\tThe damping ratio, which dictates how the spring slows down. Only works when frequency is defined. Defaults to 1. progress\t0\tWhen used with duration, it decides how far into the easing function to start from. The duration itself is unaffected. duration\tundefined\tif &gt; than 0, will switch to a duration-based animation instead of spring physics, value should be indicated in seconds (e.g. duration: 2 for a duration of 2s) frequency\tundefined\tThe frequency response (in seconds), which dictates the duration of one period in a frictionless environment. When defined, tension is derived from this, and friction is derived from this and damping. bounce\tundefined\tWhen above zero, the spring will bounce instead of overshooting when exceeding its goal value. precision\tundefined\tHow close to the end result the animated value gets before we consider it to be &quot;there&quot;. When undefined, ideal precision will be calculated by the distance from from to to restVelocity\tundefined\tThe smallest velocity before the animation is considered to be &quot;not moving&quot;. When undefined, precision is used instead.  "},{"title":"Presets​","type":1,"pageTitle":"Configs","url":"docs/Common/configs#presets","content":"There are also a couple of generic presets that will cover some common ground. RoactSpring.config = { default = { mass: 1, tension: 170, friction: 26 }, gentle = { mass: 1, tension: 120, friction: 14 }, wobbly = { mass: 1, tension: 180, friction: 12 }, stiff = { mass: 1, tension: 210, friction: 20 }, slow = { mass: 1, tension: 280, friction: 60 }, molasses = { mass: 1, tension: 280, friction: 120 }, } Copy  "},{"title":"Easings​","type":1,"pageTitle":"Configs","url":"docs/Common/configs#easings","content":"While react-spring should generally be used to with springs, sometimes parameterizing animations with durations may be required (e.g., timers). The following easing functions are supported when duration is set. In\tOut\tIn OuteaseInBack\teaseOutBack\teaseInOutBack easeInBounce\teaseOutBounce\teaseInOutBounce easeInCirc\teaseOutCirc\teaseInOutCirc easeInCubic\teaseOutCubic\teaseInOutCubic easeInElastic\teaseOutElastic\teaseInOutElastic easeInExpo\teaseOutExpo\teaseInOutExpo easeInQuad\teaseOutQuad\teaseInOutQuad easeInQuart\teaseOutQuart\teaseInOutQuart easeInQuint\teaseOutQuint\teaseInOutQuint easeInSine\teaseOutSine\teaseInOutSine api.start({ position = UDim2.fromScale(0.5, 0.5), rotation = 0, config = { mass: 10, tension: 100, friction: 50 }, }) Copy ONLY UPDATE IMPERATIVELY Due to the way easings handle interuptions, it is recommended to only update the spring values imperatively. Setting the target value midway will cause the duration timer to reset. "},{"title":"Advanced Configs​","type":1,"pageTitle":"Configs","url":"docs/Common/configs#advanced-configs","content":""},{"title":"Velocity Config​","type":1,"pageTitle":"Configs","url":"docs/Common/configs#velocity-config","content":"When a number, the velocity config applies initial velocity towards or away from the target. -- Start with initial velocity away from `to` local styles = RoactSpring.useSpring(hooks, { position = if toggle then UDim2.fromScale(0.5, 0.8) else UDim2.fromScale(0.5, 0.5), config = { velocity = -0.01 }, }) Copy For further customization on the direction of the velocity, you can pass a table of values, one for each element. -- Start with initial velocity pointed towards the top-left corner local styles = RoactSpring.useSpring(hooks, { position = if toggle then UDim2.fromScale(0.5, 0.8) else UDim2.fromScale(0.5, 0.5), config = { velocity = {-0.01, 0, -0.01, 0} }, }) Copy Passing in a single number where to equals from will not move the spring at all. This is because react-spring can't determine the direction of the velocity from one point alone. To apply a velocity, you must indicate which axes to apply it to by passing in a table of values. -- Will not do anything local styles = RoactSpring.useSpring(hooks, { position = UDim2.fromScale(0.5, 0.5), config = { velocity = -0.01 }, }) -- Will apply velocity towards the top-left corner and then return back to original position local styles = RoactSpring.useSpring(hooks, { position = UDim2.fromScale(0.5, 0.5), config = { velocity = {-0.01, 0, -0.01, 0} }, }) Copy "},{"title":"Controller","type":0,"sectionRef":"#","url":"docs/Additional Classes/controller","content":"","keywords":""},{"title":"Overview​","type":1,"pageTitle":"Controller","url":"docs/Additional Classes/controller#overview","content":"The Controller is roact-spring's heart. All primitives use it internally (including hooks). The api is very similar to the useSpring hook. This should be used when using class components. If you are using hooks, use useSpring instead. Note that the controller's api uses the colon operator unlike the hooks. function Example:init() self.styles, self.api = RoactSpring.Controller.new({ size = UDim2.fromOffset(150, 150), position = UDim2.fromScale(0.5, 0.5), }) end function Example:render() return e(&quot;TextButton&quot;, { Position = self.styles.position, Size = self.styles.size, [Roact.Event.Activated] = function() self.api:start({ size = UDim2.fromOffset(150, 150), config = { tension = 100, friction = 10 }, }) end }) end Copy "},{"title":"Demos​","type":1,"pageTitle":"Controller","url":"docs/Additional Classes/controller#demos","content":""},{"title":"Draggable element​","type":1,"pageTitle":"Controller","url":"docs/Additional Classes/controller#draggable-element","content":" "},{"title":"Imperatives","type":0,"sectionRef":"#","url":"docs/Common/imperatives","content":"","keywords":""},{"title":"Imperative API​","type":1,"pageTitle":"Imperatives","url":"docs/Common/imperatives#imperative-api","content":"Passing a function to useSpring or useSprings will return an imperative API table. The following shows the difference between using the imperative and declarative API for toggling transparency. --[[ Using declarative API ]] local toggle, setToggle = useState(false) local styles = RoactSpring.useSpring(hooks, { transparency = if toggle then 0 else 1, }) -- Later setToggle(function(prevState) return not prevState end) --[[ Using imperative API ]] local styles, api = RoactSpring.useSpring(hooks, function() return { transparency = 1 } end) -- Later api.start({ transparency = if styles.transparency:getValue() == 1 then 0 else 1 }) Copy The rest of this page will use the imperative API. You can also specify configs for each animation update. api.start({ position = UDim2.fromScale(0.5, 0.5), rotation = 0, config = { mass = 10, tension = 100, friction = 50 }, }) Copy To run tasks after an animation has finished, chain the returned promise with andThen. api.start({ position = UDim2.fromScale(0.5, 0.5), rotation = 0, }):andThen(function() print(&quot;Animation finished!&quot;) end) Copy "},{"title":"API methods​","type":1,"pageTitle":"Imperatives","url":"docs/Common/imperatives#api-methods","content":"The api table in the second value returned from a spring has the following functions: local api = { -- Start your animation optionally giving new props to merge start: (props) =&gt; Promise, -- Cancel some or all animations depending on the keys passed, no keys will cancel all. stop: (keys) =&gt; void, -- Pause some or all animations depending on the keys passed, no keys will pause all. pause: (keys) =&gt; void, } Copy note roact-spring guarantees that the api table identity is stable and won’t change on re-renders. This is why it’s safe to omit from the useEffect or useCallback dependency array. "},{"title":"Props","type":0,"sectionRef":"#","url":"docs/Common/props","content":"","keywords":""},{"title":"Overview​","type":1,"pageTitle":"Props","url":"docs/Common/props#overview","content":"RoactSpring.useSpring(hooks, { from = { ... } }) Copy All primitives inherit the following properties (though some of them may bring their own additionally): Property\tType\tDescriptionfrom\ttable\tStarting values to\ttable\tAnimates to ... delay\tnumber\tDelay in seconds before the animation starts immediate\tboolean\tPrevents animation if true. config\ttable\tSpring config (contains mass, tension, friction, etc) "},{"title":"Default props​","type":1,"pageTitle":"Props","url":"docs/Common/props#default-props","content":""},{"title":"Imperative updates​","type":1,"pageTitle":"Props","url":"docs/Common/props#imperative-updates","content":"Imperative updates inherit default props declared from passing props to useSprings or useSpring. local styles, api = RoactSpring.useSpring(hooks, function() return { position = UDim2.fromScale(0.5, 0.5) , config = { tension = 100 }, } end) hooks.useEffect(function() -- The `config` prop is inherited by the animation -- Spring will animate with tension at 100 api.start({ position = UDim2.fromScale(0.3, 0.3) }) end) Copy "},{"title":"Compatible props​","type":1,"pageTitle":"Props","url":"docs/Common/props#compatible-props","content":"The following props can have default values: configimmediate "},{"title":"useSpring","type":0,"sectionRef":"#","url":"docs/Hooks/useSpring","content":"","keywords":""},{"title":"Overview​","type":1,"pageTitle":"useSpring","url":"docs/Hooks/useSpring#overview","content":"Defines values into animated values. "},{"title":"Either: declaratively overwrite values to change the animation​","type":1,"pageTitle":"useSpring","url":"docs/Hooks/useSpring#either-declaratively-overwrite-values-to-change-the-animation","content":"If you re-render the component, the animation will update. local styles = RoactSpring.useSpring(hooks, { transparency = if toggle then 1 else 0, }) Copy If you want the animation to run on mount, you can use from to set the initial value. local styles = RoactSpring.useSpring(hooks, { from = { transparency = 0 }, to = { transparency = if toggle then 1 else 0 }, }) Copy "},{"title":"Or: pass a function that returns values, and imperatively update using the api​","type":1,"pageTitle":"useSpring","url":"docs/Hooks/useSpring#or-pass-a-function-that-returns-values-and-imperatively-update-using-the-api","content":"You will get an API table back. It will not automatically animate on mount and re-render, but you can call api.start to start the animation. Handling updates like this is generally preferred as it's more powerful. Further documentation can be found in Imperatives. local styles, api = RoactSpring.useSpring(hooks, function() return { transparency = 0 } }) -- Update spring with new props api.start({ transparency = if toggle then 1 else 0 }) -- Stop animation api.stop() Copy "},{"title":"Finally: apply styles to components​","type":1,"pageTitle":"useSpring","url":"docs/Hooks/useSpring#finally-apply-styles-to-components","content":"return Roact.createElement(&quot;Frame&quot;, { Transparency = styles.transparency, Size = UDim2.fromScale(0.3, 0.3), }) Copy "},{"title":"Properties​","type":1,"pageTitle":"useSpring","url":"docs/Hooks/useSpring#properties","content":"All properties documented in the common props apply. "},{"title":"Additional notes​","type":1,"pageTitle":"useSpring","url":"docs/Hooks/useSpring#additional-notes","content":""},{"title":"To-prop shortcut​","type":1,"pageTitle":"useSpring","url":"docs/Hooks/useSpring#to-prop-shortcut","content":"Any property that useSpring does not recognize will be combined into &quot;to&quot;, for instance transparency = 1 will become to = { transparency = 1 }. -- This... local styles = RoactSpring.useSpring({ transparency = 1 }) -- is a shortcut for this... local styles = RoactSpring.useSpring({ to = { transparency = 1 } }) Copy "},{"title":"Demos​","type":1,"pageTitle":"useSpring","url":"docs/Hooks/useSpring#demos","content":""},{"title":"Draggable element​","type":1,"pageTitle":"useSpring","url":"docs/Hooks/useSpring#draggable-element","content":" "},{"title":"useSprings","type":0,"sectionRef":"#","url":"docs/Hooks/useSprings","content":"","keywords":""},{"title":"Overview​","type":1,"pageTitle":"useSprings","url":"docs/Hooks/useSprings#overview","content":"Creates multiple springs, each with its own config. Use it for static lists, etc. "},{"title":"Either: declaratively overwrite values to change the animation​","type":1,"pageTitle":"useSprings","url":"docs/Hooks/useSprings#either-declaratively-overwrite-values-to-change-the-animation","content":"If you re-render the component with changed props, the animation will update. local springProps = {} local length = #items for index, item in ipairs(items) do table.insert(springProps, { transparency = if toggles[i] then 1 else 0, }) end local springs = RoactSpring.useSprings(hooks, length, springProps) Copy If you want the animation to run on mount, you can use from to set the initial value. local springProps = {} local length = #items for index, item in ipairs(items) do table.insert(springProps, { from = { transparency = item.transparency }, to = { transparency = if toggles[i] then 1 else 0 }, }) end local springs = RoactSpring.useSprings(hooks, length, springProps) Copy "},{"title":"Or: pass a function that returns values, and imperatively update using the api​","type":1,"pageTitle":"useSprings","url":"docs/Hooks/useSprings#or-pass-a-function-that-returns-values-and-imperatively-update-using-the-api","content":"You will get an API table back. It will not automatically animate on mount and re-render, but you can call api.start to start the animation. Handling updates like this is generally preferred as it's more powerful. Further documentation can be found in Imperatives. local length = #items local springs, api = RoactSpring.useSprings(hooks, length, function(index) return { transparency = items[index].transparency } end) -- Start animations api.start(function(index) return { position = UDim2.fromScale(0.5 * index, 0.16) } end) -- Stop all springs api.stop() Copy "},{"title":"Finally: apply styles to components​","type":1,"pageTitle":"useSprings","url":"docs/Hooks/useSprings#finally-apply-styles-to-components","content":"local contents = {} for i = 1, 4 do contents[i] = Roact.createElement(&quot;Frame&quot;, { Position = springs[i].position, Size = UDim2.fromScale(0.3, 0.3), }) end return contents Copy "},{"title":"Properties​","type":1,"pageTitle":"useSprings","url":"docs/Hooks/useSprings#properties","content":"All properties documented in the common props apply. "},{"title":"Demos​","type":1,"pageTitle":"useSprings","url":"docs/Hooks/useSprings#demos","content":""},{"title":"Draggable list​","type":1,"pageTitle":"useSprings","url":"docs/Hooks/useSprings#draggable-list","content":" "},{"title":"useTrail","type":0,"sectionRef":"#","url":"docs/Hooks/useTrail","content":"","keywords":""},{"title":"Overview​","type":1,"pageTitle":"useTrail","url":"docs/Hooks/useTrail#overview","content":"Creates multiple springs with a single config, each spring will follow the previous one. Use it for staggered animations. "},{"title":"Either: declaratively overwrite values to change the animation​","type":1,"pageTitle":"useTrail","url":"docs/Hooks/useTrail#either-declaratively-overwrite-values-to-change-the-animation","content":"If you re-render the component with changed props, the animation will update. local springProps = {} local length = #items for index, item in ipairs(items) do table.insert(springProps, { transparency = if toggles[i] then 1 else 0, }) end local springs = RoactSpring.useTrail(hooks, length, springProps) Copy If you want the animation to run on mount, you can use from to set the initial value. local springProps = {} local length = #items for index, item in ipairs(items) do table.insert(springProps, { from = { transparency = item.transparency }, to = { transparency = if toggles[i] then 1 else 0 }, }) end local springs = RoactSpring.useTrail(hooks, length, springProps) Copy "},{"title":"Or: pass a function that returns values, and imperatively update using the api​","type":1,"pageTitle":"useTrail","url":"docs/Hooks/useTrail#or-pass-a-function-that-returns-values-and-imperatively-update-using-the-api","content":"You will get an API table back. It will not automatically animate on mount and re-render, but you can call api.start to start the animation. Handling updates like this is generally preferred as it's more powerful. Further documentation can be found in Imperatives. local length = #items local springs, api = RoactSpring.useTrail(hooks, length, function(index) return { transparency = items[index].transparency } end) -- Start animations api.start(function(index) return { position = UDim2.fromScale(0.5 * index, 0.16) } end) -- Stop all springs api.stop() Copy "},{"title":"Finally: apply styles to components​","type":1,"pageTitle":"useTrail","url":"docs/Hooks/useTrail#finally-apply-styles-to-components","content":"local contents = {} for i = 1, 4 do contents[i] = Roact.createElement(&quot;Frame&quot;, { Position = springs[i].position, Size = UDim2.fromScale(0.3, 0.3), }) end return contents Copy "},{"title":"Properties​","type":1,"pageTitle":"useTrail","url":"docs/Hooks/useTrail#properties","content":"All properties documented in the common props apply. By default, each spring will start 0.1 seconds after the previous one. You can override this by passing a delay property. -- Now each spring will start 0.2 seconds after the previous one local springs, api = RoactSpring.useTrail(hooks, length, function(index) return { transparency = items[index].transparency, delay = 0.2, } end) Copy You can also pass a delay property to each spring individually. -- The first spring will start 0.1 seconds after the previous one, the second 0.2 seconds, and so on local springs, api = RoactSpring.useTrail(hooks, length, function(index) return { transparency = items[index].transparency, delay = index * 0.1, } end) Copy "},{"title":"Demos​","type":1,"pageTitle":"useTrail","url":"docs/Hooks/useTrail#demos","content":""},{"title":"Staggered list​","type":1,"pageTitle":"useTrail","url":"docs/Hooks/useTrail#staggered-list","content":" "},{"title":"Staggered text​","type":1,"pageTitle":"useTrail","url":"docs/Hooks/useTrail#staggered-text","content":" "},{"title":"Trailing elements​","type":1,"pageTitle":"useTrail","url":"docs/Hooks/useTrail#trailing-elements","content":" "},{"title":"Introduction","type":0,"sectionRef":"#","url":"docs/intro","content":"","keywords":""},{"title":"Installation​","type":1,"pageTitle":"Introduction","url":"docs/intro#installation","content":"Add the latest version of roact-spring to your wally.toml (e.g., RoactSpring = &quot;chriscerie/roact-spring@^0.0&quot;) "},{"title":"Why springs and not durations​","type":1,"pageTitle":"Introduction","url":"docs/intro#why-springs-and-not-durations","content":"note Motivation from react-spring The principle you will be working with is called a spring, it does not have a defined curve or a set duration. In that it differs greatly from the animation you are probably used to. We think of animation in terms of time and curves, but that in itself causes most of the struggle we face when trying to make elements on the screen move naturally, because nothing in the real world moves like that.  We are so used to time-based animation that we believe that struggle is normal, dealing with arbitrary curves, easings, time waterfalls, not to mention getting this all in sync. As Andy Matuschak (ex Apple UI-Kit developer) expressed it once: Animation APIs parameterized by duration and curve are fundamentally opposed to continuous, fluid interactivity. "}]