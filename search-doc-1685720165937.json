[{"title":"Controller","type":0,"sectionRef":"#","url":"/roact-spring/docs/Additional Classes/controller","content":"","keywords":""},{"title":"Overview​","type":1,"pageTitle":"Controller","url":"/roact-spring/docs/Additional Classes/controller#overview","content":"The Controller is roact-spring's heart. All primitives use it internally (including hooks). The api is very similar to the useSpring hook. This should be used when using class components. If you are using hooks, use useSpring instead. Note that the controller's api uses the colon operator unlike the hooks. function Example:init() self.styles, self.api = RoactSpring.Controller.new({ size = UDim2.fromOffset(150, 150), position = UDim2.fromScale(0.5, 0.5), }) end function Example:render() return e(&quot;TextButton&quot;, { Position = self.styles.position, Size = self.styles.size, [React.Event.Activated] = function() self.api:start({ size = UDim2.fromOffset(150, 150), config = { tension = 100, friction = 10 }, }) end }) end  "},{"title":"Demos​","type":1,"pageTitle":"Controller","url":"/roact-spring/docs/Additional Classes/controller#demos","content":""},{"title":"Draggable element​","type":1,"pageTitle":"Controller","url":"/roact-spring/docs/Additional Classes/controller#draggable-element","content":" "},{"title":"Additional Notes","type":0,"sectionRef":"#","url":"/roact-spring/docs/Additional Notes","content":"","keywords":""},{"title":"Thinking in alpha values​","type":1,"pageTitle":"Additional Notes","url":"/roact-spring/docs/Additional Notes#thinking-in-alpha-values","content":"roact-spring supports animating many different data types. However, sometimes it may be more convenient to animate from 0 to 1 and subscribe elements to it so they can interpolate between different values themselves. This is especially helpful when you want to subscribe multiple elements with different values to a single spring. This is also helpful to ensure different elements that you want to animate together will truly stay together. You don't run the risk of animating some elements but forgetting to animate others. One downside to this approach is that it's only convenient when elements are animating along a line between only 2 points. If you want to animate among arbitrary positions, using the relevant data type directly is more appropriate. "},{"title":"Using different springs for each element​","type":1,"pageTitle":"Additional Notes","url":"/roact-spring/docs/Additional Notes#using-different-springs-for-each-element","content":"local function Example(_) local styles, api = RoactSpring.useSpring(function() return { position1 = UDim2.fromScale(0.2, 0.2), position2 = UDim2.fromScale(0.1, 0.8), position3 = UDim2.fromScale(0.6, 0.4), } end) React.useEffect(function() -- We need to call `api.start` for each value api.start({ position1 = UDim2.fromScale(0.8, 0.2) }) api.start({ position2 = UDim2.fromScale(0.2, 0.6) }) api.start({ position3 = UDim2.fromScale(0.5, 0.9) }) end, {}) return React.createElement(React.Fragment, nil, { Frame1 = React.createElement(&quot;Frame&quot;, { Position = styles.position1, }), Frame2 = React.createElement(&quot;Frame&quot;, { Position = styles.position2, }), Frame3 = React.createElement(&quot;Frame&quot;, { Position = styles.position3, }), }) end  "},{"title":"Using alpha values​","type":1,"pageTitle":"Additional Notes","url":"/roact-spring/docs/Additional Notes#using-alpha-values","content":"local function Example(_) local styles, api = RoactSpring.useSpring(function() return { alpha = 0, } end) React.useEffect(function() -- We only have to call `api.start` once api.start({ alpha = 1 }) end, {}) return React.createElement(React.Fragment, nil, { Frame1 = React.createElement(&quot;Frame&quot;, { Position = styles.position:map(function(alpha) return UDim2.fromScale(0.2, 0.2):Lerp(UDim2.fromScale(0.8, 0.2), alpha) end), }), Frame2 = React.createElement(&quot;Frame&quot;, { Position = styles.position:map(function(alpha) return UDim2.fromScale(0.1, 0.8):Lerp(UDim2.fromScale(0.2, 0.6), alpha) end), }), Frame3 = React.createElement(&quot;Frame&quot;, { Position = styles.position:map(function(alpha) return UDim2.fromScale(0.6, 0.4):Lerp(UDim2.fromScale(0.5, 0.9), alpha) end), }), }) end  "},{"title":"Configs","type":0,"sectionRef":"#","url":"/roact-spring/docs/Common/configs","content":"","keywords":""},{"title":"Overview​","type":1,"pageTitle":"Configs","url":"/roact-spring/docs/Common/configs#overview","content":"Springs are configurable and can be tuned. If you want to adjust these settings, you can provide a default config table to useSpring: local styles, api = RoactSpring.useSpring(function() return { from = { position = UDim2.fromScale(0.5, 0.5), rotation = 0, }, config = { mass = 10, tension = 100, friction = 50 }, } })  Configs can also be adjusted when animating the spring. If there isn't any config provided, the default config will be used. api.start({ position = UDim2.fromScale(0.5, 0.5), rotation = 0, config = { mass = 10, tension = 100, friction = 50 }, })  The following configs are available: Property\tDefault\tDescriptionmass\t1\tspring mass tension\t170\tspring energetic load friction\t26\tspring resistance clamp\tfalse\twhen true, stops the spring once it overshoots its boundaries velocity\t0\tinitial velocity, see velocity config for more details easing\tt =&gt; t\tlinear by default, there is a multitude of easings available here damping\t1\tThe damping ratio, which dictates how the spring slows down. Only works when frequency is defined. Defaults to 1. progress\t0\tWhen used with duration, it decides how far into the easing function to start from. The duration itself is unaffected. duration\tundefined\tif &gt; than 0, will switch to a duration-based animation instead of spring physics, value should be indicated in seconds (e.g. duration: 2 for a duration of 2s) frequency\tundefined\tThe frequency response (in seconds), which dictates the duration of one period in a frictionless environment. When defined, tension is derived from this, and friction is derived from this and damping. bounce\tundefined\tWhen above zero, the spring will bounce instead of overshooting when exceeding its goal value. precision\tundefined\tHow close to the end result the animated value gets before we consider it to be &quot;there&quot;. When undefined, ideal precision will be calculated by the distance from from to to restVelocity\tundefined\tThe smallest velocity before the animation is considered to be &quot;not moving&quot;. When undefined, precision is used instead.  "},{"title":"Presets​","type":1,"pageTitle":"Configs","url":"/roact-spring/docs/Common/configs#presets","content":"There are also a couple of generic presets that will cover some common ground. RoactSpring.config = { default = { mass: 1, tension: 170, friction: 26 }, gentle = { mass: 1, tension: 120, friction: 14 }, wobbly = { mass: 1, tension: 180, friction: 12 }, stiff = { mass: 1, tension: 210, friction: 20 }, slow = { mass: 1, tension: 280, friction: 60 }, molasses = { mass: 1, tension: 280, friction: 120 }, }   "},{"title":"Easings​","type":1,"pageTitle":"Configs","url":"/roact-spring/docs/Common/configs#easings","content":"While react-spring should generally be used to with springs, sometimes parameterizing animations with durations may be required (e.g., timers). The following easing functions are supported when duration is set. In\tOut\tIn OuteaseInBack\teaseOutBack\teaseInOutBack easeInBounce\teaseOutBounce\teaseInOutBounce easeInCirc\teaseOutCirc\teaseInOutCirc easeInCubic\teaseOutCubic\teaseInOutCubic easeInElastic\teaseOutElastic\teaseInOutElastic easeInExpo\teaseOutExpo\teaseInOutExpo easeInQuad\teaseOutQuad\teaseInOutQuad easeInQuart\teaseOutQuart\teaseInOutQuart easeInQuint\teaseOutQuint\teaseInOutQuint easeInSine\teaseOutSine\teaseInOutSine api.start({ position = UDim2.fromScale(0.5, 0.5), rotation = 0, config = { mass: 10, tension: 100, friction: 50 }, })  ONLY UPDATE IMPERATIVELY Due to the way easings handle interruptions, it is recommended to only update the spring values imperatively. Setting the target value midway will cause the duration timer to reset. "},{"title":"Advanced Configs​","type":1,"pageTitle":"Configs","url":"/roact-spring/docs/Common/configs#advanced-configs","content":""},{"title":"Velocity Config​","type":1,"pageTitle":"Configs","url":"/roact-spring/docs/Common/configs#velocity-config","content":"When a number, the velocity config applies initial velocity towards or away from the target. -- Start with initial velocity away from `to` local styles = RoactSpring.useSpring({ position = if toggle then UDim2.fromScale(0.5, 0.8) else UDim2.fromScale(0.5, 0.5), config = { velocity = -0.01 }, })  For further customization on the direction of the velocity, you can pass a table of values, one for each element. -- Start with initial velocity pointed towards the top-left corner local styles = RoactSpring.useSpring({ position = if toggle then UDim2.fromScale(0.5, 0.8) else UDim2.fromScale(0.5, 0.5), config = { velocity = {-0.01, 0, -0.01, 0} }, })  Passing in a single number where to equals from will not move the spring at all. This is because react-spring can't determine the direction of the velocity from one point alone. To apply a velocity, you must indicate which axes to apply it to by passing in a table of values. -- Will not do anything local styles = RoactSpring.useSpring({ position = UDim2.fromScale(0.5, 0.5), config = { velocity = -0.01 }, }) -- Will apply velocity towards the top-left corner and then return back to original position local styles = RoactSpring.useSpring({ position = UDim2.fromScale(0.5, 0.5), config = { velocity = {-0.01, 0, -0.01, 0} }, })  "},{"title":"Imperatives","type":0,"sectionRef":"#","url":"/roact-spring/docs/Common/imperatives","content":"","keywords":""},{"title":"Imperative API​","type":1,"pageTitle":"Imperatives","url":"/roact-spring/docs/Common/imperatives#imperative-api","content":"Passing a function to useSpring or useSprings will return an imperative API table. The following shows the difference between using the imperative and declarative API for toggling transparency. --[[ Using declarative API ]] local toggle, setToggle = useState(false) local styles = RoactSpring.useSpring({ transparency = if toggle then 0 else 1, }) -- Later setToggle(function(prevState) return not prevState end) --[[ Using imperative API ]] local styles, api = RoactSpring.useSpring(function() return { transparency = 1 } end) -- Later api.start({ transparency = if styles.transparency:getValue() == 1 then 0 else 1 })  The rest of this page will use the imperative API. You can also specify configs for each animation update. api.start({ position = UDim2.fromScale(0.5, 0.5), rotation = 0, config = { mass = 10, tension = 100, friction = 50 }, })  To run tasks after an animation has finished, chain the returned promise with andThen. api.start({ position = UDim2.fromScale(0.5, 0.5), rotation = 0, }):andThen(function() print(&quot;Animation finished!&quot;) end)  "},{"title":"API methods​","type":1,"pageTitle":"Imperatives","url":"/roact-spring/docs/Common/imperatives#api-methods","content":"The api table in the second value returned from a spring has the following functions: local api = { -- Start your animation optionally giving new props to merge start: (props) =&gt; Promise, -- Cancel some or all animations depending on the keys passed, no keys will cancel all. stop: (keys) =&gt; void, -- Pause some or all animations depending on the keys passed, no keys will pause all. pause: (keys) =&gt; void, }  note roact-spring guarantees that the api table identity is stable and won’t change on re-renders. This is why it’s safe to omit from the useEffect or useCallback dependency array. "},{"title":"Props","type":0,"sectionRef":"#","url":"/roact-spring/docs/Common/props","content":"","keywords":""},{"title":"Overview​","type":1,"pageTitle":"Props","url":"/roact-spring/docs/Common/props#overview","content":"RoactSpring.useSpring({ from = { ... } })  All primitives inherit the following properties (though some of them may bring their own additionally): Property\tType\tDescriptionfrom\ttable\tStarting values to\ttable\tAnimates to ... loop\ttable/fn/bool\tLooping settings, see loop prop for more details delay\tnumber\tDelay in seconds before the animation starts immediate\tboolean\tPrevents animation if true config\ttable\tSpring config (contains mass, tension, friction, etc) reset\tbool\tThe spring starts to animate from scratch (from -&gt; to) if set true default\tbool\tSets default value of compatible props if true. See default props for more details "},{"title":"Advanced Props​","type":1,"pageTitle":"Props","url":"/roact-spring/docs/Common/props#advanced-props","content":""},{"title":"Loop prop​","type":1,"pageTitle":"Props","url":"/roact-spring/docs/Common/props#loop-prop","content":"Use loop = true to repeat an animation. -- Transparency repeatedly animates from 0 to 1 local styles = RoactSpring.useSpring({ from = { transparency = 0 }, to = { transparency = 1 }, loop = true, })  "},{"title":"The loop function​","type":1,"pageTitle":"Props","url":"/roact-spring/docs/Common/props#the-loop-function","content":"Pass a function to be called after each loop. Return true to continue looping, or false to stop. -- Transparency animates from 0 to 1 three times local count = React.useRef(0) local styles = RoactSpring.useSpring({ from = { transparency = 0 }, to = { transparency = 1 }, loop = function() count += 1 return 3 &gt; count.value end, })  "},{"title":"The loop table​","type":1,"pageTitle":"Props","url":"/roact-spring/docs/Common/props#the-loop-table","content":"Define a loop table to customize the loop animation separately from the initial animation. It may contain any of the useSpring props. For example, if delay: 1 is used, the loop animation will delay for 1 second on each loop. -- Transparency repeatedly animates from 0 to 1 with 1 second delays local count = React.useRef(0) local styles = RoactSpring.useSpring({ from = { transparency = 0 }, to = { transparency = 1 }, loop = { delay = 1, reset = true }, })  Inherited props​ The loop object is always merged into a copy of the props object it was defined in. The following example shows a loop animation that inherits its config prop. -- The loop doesn't run more than once local styles = RoactSpring.useSpring({ from = { transparency = 0 }, loop = { transparency = 1 }, })  ⚠️ The loop doesn't run more than once. That's because some props are never inherited. These props include default, reset, and reverse To loop the animation, try adding reset = true to the loop prop in the above example. Alternatively, you could add from = { transparency: 1 } to get the same effect. Lastly, try adding config = { friction: 5 } to the loop object. This overrides the inherited config with a springy animation. -- Transparency repeatedly animates from 0 to 1 local styles = RoactSpring.useSpring({ from = { transparency = 0 }, loop = { transparency = 1, reset = true, }, }) -- Transparency repeatedly animates from 0 to 1 local styles = RoactSpring.useSpring({ from = { transparency = 0 }, loop = { transparency = 1, from = { transparency = 1 }, }, })  "},{"title":"Reset prop​","type":1,"pageTitle":"Props","url":"/roact-spring/docs/Common/props#reset-prop","content":"Use the reset prop to start the animation from scratch. When undefined in imperative updates, the spring will assume reset is true if from is passed. local styles, api = RoactSpring.useSpring(function() return { transparency = 0.5 } end) -- The spring will start from 0 api.start({ from = { transparency = 0 }, to = { transparency = 1 }, }) -- The spring will ignore `from` and start from its current position api.start({ reset = false, from = { transparency = 0 }, to = { transparency = 1 }, })  In declarative updates, the spring will assume reset is false if reset is not passed in. -- The spring will start from 0.2 on mount and ignore `from` on future updates local styles = RoactSpring.useSpring({ from = { transparency = 0.2 }, to = { transparency = if toggle then 0 else 1 }, }, { toggle }) -- The spring will always start from scratch from 0.2 local styles = RoactSpring.useSpring({ reset = true, from = { transparency = 0.2 }, to = { transparency = if toggle then 0 else 1 }, }, { toggle })  "},{"title":"Default Props​","type":1,"pageTitle":"Props","url":"/roact-spring/docs/Common/props#default-props","content":"The default prop lets you set the default value of certain props defined in the same update. "},{"title":"Declarative updates​","type":1,"pageTitle":"Props","url":"/roact-spring/docs/Common/props#declarative-updates","content":"For the declarative API, this prop is true by default. "},{"title":"Imperative updates​","type":1,"pageTitle":"Props","url":"/roact-spring/docs/Common/props#imperative-updates","content":"Imperative updates can use default: true to set default props. local styles, api = RoactSpring.useSpring(function() return { position = UDim2.fromScale(0.5, 0.5), config = { tension = 100 }, default = true, } end) React.useEffect(function() -- The `config` prop is inherited by the animation -- Spring will animate with tension at 100 api.start({ position = UDim2.fromScale(0.3, 0.3) }) end)  "},{"title":"Compatible props​","type":1,"pageTitle":"Props","url":"/roact-spring/docs/Common/props#compatible-props","content":"The following props can have default values: configimmediate "},{"title":"Getting Started","type":0,"sectionRef":"#","url":"/roact-spring/docs/Getting Started","content":"","keywords":""},{"title":"Getting started with function components and hooks​","type":1,"pageTitle":"Getting Started","url":"/roact-spring/docs/Getting Started#getting-started-with-function-components-and-hooks","content":"Getting started with roact-spring is easy. For function components with hooks, the basic spring is useSpring, but the same concept applies to all animation primitives. Let's have a look... local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local React = require(ReplicatedStorage.Packages.React) local RoactSpring = require(ReplicatedStorage.Packages.RoactSpring) -- When button is pressed, animate transparency to 0 local function App(_) local styles, api = RoactSpring.useSpring(function() return { transparency = 1 } end) return React.CreateElement(&quot;TextButton&quot;, { Size = UDim2.fromScale(0.5, 0.5), Transparency = styles.transparency, [React.Event.Activated] = function() api.start({ transparency = 0 }) end, }) end  roact-spring supports both Roact17 and legacy Roact with roact-hooks. Usage with legacy Roact and roact-hooks requires you to pass the hooks table to roact-spring's hooks. Using Roact17:​ local function App(_) local styles, api = RoactSpring.useSpring(function() return { transparency = 1 } end) end  Using legacy Roact with roact-hooks:​ local function App(_, hooks) local styles, api = RoactSpring.useSpring(hooks, function() return { transparency = 1 } end) end  The rest of this documentation's examples will assume we are using Roact17. "},{"title":"Getting started with class components​","type":1,"pageTitle":"Getting Started","url":"/roact-spring/docs/Getting Started#getting-started-with-class-components","content":"For class components, the basic spring is Controller. Let's have a look... note Function components with hooks are always preferred over class components. For more information, see React's motivation for hooks. local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local React = require(ReplicatedStorage.Packages.React) local RoactSpring = require(ReplicatedStorage.Packages.RoactSpring) function App:init() self.styles, self.api = RoactSpring.Controller.new({ transparency = 1 }) end -- When button is pressed, animate transparency to 0 function App:render() return React.CreateElement(&quot;TextButton&quot;, { Size = UDim2.fromScale(0.5, 0.5), Transparency = self.styles.transparency, [React.Event.Activated] = function() self.api:start({ transparency = 0 }) end, }) end  "},{"title":"Up-front interpolation​","type":1,"pageTitle":"Getting Started","url":"/roact-spring/docs/Getting Started#up-front-interpolation","content":"Springs don't just handle numbers! They take the following types: NumberColor3Vector2Vector3UDimUDim2 "},{"title":"Next steps​","type":1,"pageTitle":"Getting Started","url":"/roact-spring/docs/Getting Started#next-steps","content":"If you are using hooks, read useSpring as well as props and configs. After, read through the other provided hooks for more advanced animations. If you are using class components, read Controller as well as props and configs. "},{"title":"useSpring","type":0,"sectionRef":"#","url":"/roact-spring/docs/Hooks/useSpring","content":"","keywords":""},{"title":"Overview​","type":1,"pageTitle":"useSpring","url":"/roact-spring/docs/Hooks/useSpring#overview","content":"Defines values into animated values. "},{"title":"Either: declaratively overwrite values to change the animation​","type":1,"pageTitle":"useSpring","url":"/roact-spring/docs/Hooks/useSpring#either-declaratively-overwrite-values-to-change-the-animation","content":"If you re-render the component, the animation will update. local styles = RoactSpring.useSpring({ transparency = if toggle then 1 else 0, })  If you want the animation to run on mount, you can use from to set the initial value. local styles = RoactSpring.useSpring({ from = { transparency = 0 }, to = { transparency = if toggle then 1 else 0 }, })  "},{"title":"Or: pass a function that returns values, and imperatively update using the api​","type":1,"pageTitle":"useSpring","url":"/roact-spring/docs/Hooks/useSpring#or-pass-a-function-that-returns-values-and-imperatively-update-using-the-api","content":"You will get an API table back. It will not automatically animate on mount and re-render, but you can call api.start to start the animation. Handling updates like this is generally preferred as it's more powerful. Further documentation can be found in Imperatives. local styles, api = RoactSpring.useSpring(function() return { transparency = 0 } }) -- Update spring with new props api.start({ transparency = if toggle then 1 else 0 }) -- Stop animation api.stop()  "},{"title":"Finally: apply styles to components​","type":1,"pageTitle":"useSpring","url":"/roact-spring/docs/Hooks/useSpring#finally-apply-styles-to-components","content":"return React.createElement(&quot;Frame&quot;, { Transparency = styles.transparency, Size = UDim2.fromScale(0.3, 0.3), })  "},{"title":"Properties​","type":1,"pageTitle":"useSpring","url":"/roact-spring/docs/Hooks/useSpring#properties","content":"All properties documented in the common props apply. "},{"title":"Additional notes​","type":1,"pageTitle":"useSpring","url":"/roact-spring/docs/Hooks/useSpring#additional-notes","content":""},{"title":"To-prop shortcut​","type":1,"pageTitle":"useSpring","url":"/roact-spring/docs/Hooks/useSpring#to-prop-shortcut","content":"Any property that useSpring does not recognize will be combined into &quot;to&quot;, for instance transparency = 1 will become to = { transparency = 1 }. -- This... local styles = RoactSpring.useSpring({ transparency = 1 }) -- is a shortcut for this... local styles = RoactSpring.useSpring({ to = { transparency = 1 } })  "},{"title":"Styles is a table of bindings​","type":1,"pageTitle":"useSpring","url":"/roact-spring/docs/Hooks/useSpring#styles-is-a-table-of-bindings","content":"The styles table is just a table of bindings. This means you can map them to props as you could for any other bindings if you wanted to achieve custom behavior. Animating with alpha values is a common use case for this. local function Example(_) local styles, api = RoactSpring.useSpring(function() return { alpha = 0, } end) React.useEffect(function() api.start({ alpha = 1 }) end, {}) return React.createElement(&quot;Frame&quot;, { Transparency = styles.alpha, Position = styles.alpha:map(function(alpha) return UDim2.fromScale(0.2, 0.2):Lerp(UDim2.fromScale(0.8, 0.2), alpha) end), }) end  "},{"title":"Demos​","type":1,"pageTitle":"useSpring","url":"/roact-spring/docs/Hooks/useSpring#demos","content":""},{"title":"Draggable element​","type":1,"pageTitle":"useSpring","url":"/roact-spring/docs/Hooks/useSpring#draggable-element","content":" "},{"title":"useSprings","type":0,"sectionRef":"#","url":"/roact-spring/docs/Hooks/useSprings","content":"","keywords":""},{"title":"Overview​","type":1,"pageTitle":"useSprings","url":"/roact-spring/docs/Hooks/useSprings#overview","content":"Creates multiple springs, each with its own config. Use it for static lists, etc. "},{"title":"Either: declaratively overwrite values to change the animation​","type":1,"pageTitle":"useSprings","url":"/roact-spring/docs/Hooks/useSprings#either-declaratively-overwrite-values-to-change-the-animation","content":"If you re-render the component with changed props, the animation will update. local springProps = {} local length = #items for index, item in ipairs(items) do table.insert(springProps, { transparency = if toggles[i] then 1 else 0, }) end local springs = RoactSpring.useSprings(length, springProps)  If you want the animation to run on mount, you can use from to set the initial value. local springProps = {} local length = #items for index, item in ipairs(items) do table.insert(springProps, { from = { transparency = item.transparency }, to = { transparency = if toggles[i] then 1 else 0 }, }) end local springs = RoactSpring.useSprings(length, springProps)  "},{"title":"Or: pass a function that returns values, and imperatively update using the api​","type":1,"pageTitle":"useSprings","url":"/roact-spring/docs/Hooks/useSprings#or-pass-a-function-that-returns-values-and-imperatively-update-using-the-api","content":"You will get an API table back. It will not automatically animate on mount and re-render, but you can call api.start to start the animation. Handling updates like this is generally preferred as it's more powerful. Further documentation can be found in Imperatives. local length = #items local springs, api = RoactSpring.useSprings(length, function(index) return { transparency = items[index].transparency } end) -- Start animations api.start(function(index) return { position = UDim2.fromScale(0.5 * index, 0.16) } end) -- Stop all springs api.stop()  "},{"title":"Finally: apply styles to components​","type":1,"pageTitle":"useSprings","url":"/roact-spring/docs/Hooks/useSprings#finally-apply-styles-to-components","content":"local contents = {} for i = 1, 4 do contents[i] = React.createElement(&quot;Frame&quot;, { Position = springs[i].position, Size = UDim2.fromScale(0.3, 0.3), }) end return contents  "},{"title":"Properties​","type":1,"pageTitle":"useSprings","url":"/roact-spring/docs/Hooks/useSprings#properties","content":"All properties documented in the common props apply. "},{"title":"Demos​","type":1,"pageTitle":"useSprings","url":"/roact-spring/docs/Hooks/useSprings#demos","content":""},{"title":"Draggable list​","type":1,"pageTitle":"useSprings","url":"/roact-spring/docs/Hooks/useSprings#draggable-list","content":" "},{"title":"Introduction","type":0,"sectionRef":"#","url":"/roact-spring/docs/intro","content":"","keywords":""},{"title":"Installation​","type":1,"pageTitle":"Introduction","url":"/roact-spring/docs/intro#installation","content":""},{"title":"Wally​","type":1,"pageTitle":"Introduction","url":"/roact-spring/docs/intro#wally","content":"roact-spring has two packages to support Roact17 and legacy Roact. It is important to install the correct package or you will encounter bugs. To install, add the latest version of roact-spring to your wally.toml: With Roact17​ RoactSpring = &quot;chriscerie/react-spring@&lt;version&gt;&quot;  With legacy Roact​ RoactSpring = &quot;chriscerie/roact-spring@&lt;version&gt;&quot;  "},{"title":"roblox-ts​","type":1,"pageTitle":"Introduction","url":"/roact-spring/docs/intro#roblox-ts","content":"roact-spring is also available for roblox-ts projects. Install it with npm: npm i @rbxts/roact-spring  "},{"title":"Why springs and not durations​","type":1,"pageTitle":"Introduction","url":"/roact-spring/docs/intro#why-springs-and-not-durations","content":"note Motivation from react-spring The principle you will be working with is called a spring, it does not have a defined curve or a set duration. In that it differs greatly from the animation you are probably used to. We think of animation in terms of time and curves, but that in itself causes most of the struggle we face when trying to make elements on the screen move naturally, because nothing in the real world moves like that.  We are so used to time-based animation that we believe that struggle is normal, dealing with arbitrary curves, easings, time waterfalls, not to mention getting this all in sync. As Andy Matuschak (ex Apple UI-Kit developer) expressed it once: Animation APIs parameterized by duration and curve are fundamentally opposed to continuous, fluid interactivity. "},{"title":"useTrail","type":0,"sectionRef":"#","url":"/roact-spring/docs/Hooks/useTrail","content":"","keywords":""},{"title":"Overview​","type":1,"pageTitle":"useTrail","url":"/roact-spring/docs/Hooks/useTrail#overview","content":"Creates multiple springs with a single config, each spring will follow the previous one. Use it for staggered animations. "},{"title":"Either: declaratively overwrite values to change the animation​","type":1,"pageTitle":"useTrail","url":"/roact-spring/docs/Hooks/useTrail#either-declaratively-overwrite-values-to-change-the-animation","content":"If you re-render the component with changed props, the animation will update. local springProps = {} local length = #items for index, item in ipairs(items) do table.insert(springProps, { transparency = if toggles[i] then 1 else 0, }) end local springs = RoactSpring.useTrail(length, springProps)  If you want the animation to run on mount, you can use from to set the initial value. local springProps = {} local length = #items for index, item in ipairs(items) do table.insert(springProps, { from = { transparency = item.transparency }, to = { transparency = if toggles[i] then 1 else 0 }, }) end local springs = RoactSpring.useTrail(length, springProps)  "},{"title":"Or: pass a function that returns values, and imperatively update using the api​","type":1,"pageTitle":"useTrail","url":"/roact-spring/docs/Hooks/useTrail#or-pass-a-function-that-returns-values-and-imperatively-update-using-the-api","content":"You will get an API table back. It will not automatically animate on mount and re-render, but you can call api.start to start the animation. Handling updates like this is generally preferred as it's more powerful. Further documentation can be found in Imperatives. local length = #items local springs, api = RoactSpring.useTrail(length, function(index) return { transparency = items[index].transparency } end) -- Start animations api.start(function(index) return { position = UDim2.fromScale(0.5 * index, 0.16) } end) -- Stop all springs api.stop()  "},{"title":"Finally: apply styles to components​","type":1,"pageTitle":"useTrail","url":"/roact-spring/docs/Hooks/useTrail#finally-apply-styles-to-components","content":"local contents = {} for i = 1, 4 do contents[i] = React.createElement(&quot;Frame&quot;, { Position = springs[i].position, Size = UDim2.fromScale(0.3, 0.3), }) end return contents  "},{"title":"Properties​","type":1,"pageTitle":"useTrail","url":"/roact-spring/docs/Hooks/useTrail#properties","content":"All properties documented in the common props apply. By default, each spring will start 0.1 seconds after the previous one. You can override this by passing a delay property. -- Now each spring will start 0.2 seconds after the previous one local springs, api = RoactSpring.useTrail(length, function(index) return { transparency = items[index].transparency, delay = 0.2, } end)  You can also pass a delay property to each spring individually. -- The first spring will start 0.1 seconds after the previous one, the second 0.2 seconds, and so on local springs, api = RoactSpring.useTrail(length, function(index) return { transparency = items[index].transparency, delay = index * 0.1, } end)  "},{"title":"Demos​","type":1,"pageTitle":"useTrail","url":"/roact-spring/docs/Hooks/useTrail#demos","content":""},{"title":"Staggered list​","type":1,"pageTitle":"useTrail","url":"/roact-spring/docs/Hooks/useTrail#staggered-list","content":" "},{"title":"Staggered text​","type":1,"pageTitle":"useTrail","url":"/roact-spring/docs/Hooks/useTrail#staggered-text","content":" "},{"title":"Trailing elements​","type":1,"pageTitle":"useTrail","url":"/roact-spring/docs/Hooks/useTrail#trailing-elements","content":" "}]